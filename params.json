{"name":"Interruptus","tagline":"Infrastructure for scalable monitoring","body":"Interruptus\r\n================\r\n\r\nA framework for scalable monitoring.\r\n\r\n<pre width=30>\r\n            _.---._\r\n        .-'         '-.\r\n     .'                 '.\r\n    '       '.   .'       '\r\n   / /        \\ /        \\ \\\r\n  '  |         :         |  '\r\n /   |         .         |   \\\r\n |   \\         |         /   |\r\n '. . \\        |        / . .'\r\n  |   .\\      .'.      /.   |\r\n  \\  .  `-           -'  .  /\r\n   '.      .. ... ..      .'\r\n    |  `` ` .     . ` ``  |\r\n    | .-_-.  '. .'  .-_-. |\r\n   .'( (O) )|  :  |( (O) )'.\r\n    \\.'---'/   :   \\'---'./\r\n      \\_ .'  . ' .  '. _/\r\n     .' /             \\ '.\r\n     './ / /  / \\ \\  \\ \\.'\r\n      : | | /|  : |  | :\r\n      | : | \\\\  | '  : |\r\n      | /\\ \\/ \\ | : /\\ :\r\n      ' :/\\ \\ : ' ||  \\ \\\r\n      / | /\\ \\| : ' \\  \\ \\\r\n     / / /  \\/ /| :  |  \\ \\\r\n    / / :   / /\\ \\ \\ /   \\ \\\r\n   ' /\\ \\  | /\\ :.\\ \\    / |\r\n   \\ \\ \\ \\ \\/ / || \\ \\   \\/\r\n    \\/  \\|    \\/ \\/ |/\r\n    \r\n</pre>\r\n\r\nAuthors\r\n=======\r\n\r\nMark Steele <mark@control-alt-del.org>\r\n\r\nFabio \"Fantastico\" B. Silva <fabio.bat.silva@gmail.com>\r\n\r\n\r\nGoals\r\n=========\r\n\r\n## Scalability\r\n\r\nA monitoring system should scale to fit the size of the systems you wish to monitor. Interruptus is designed to target the high end of the spectrum here as it requires multiple nodes and roles in an optimal deployment. \r\n\r\nGuestimated initial performance targets for this system should be able to process at least tens of thousands of data points per second. Benchmarks to follow.\r\n\r\n## Efficiency\r\n\r\nIn order to achieve effective monitoring in large environments, a single data polling instance (eg: nagios) becomes a bottleneck and dangerous single point of failure.\r\n\r\nThe monitoring approach I would therefore propose is to use efficient node based polling software (for example collectd deployed to each node) to push data to Interruptus. There is of course nothing stopping you from using Nagios to poll all your nodes and push data to Interruptus.\r\n\r\nI'm also a fan of not reinventing the wheel. That's why Interruptus leverages a best of breed software stack to focus on the core of the solution (monitoring!).\r\n\r\nFor data transport, the excellent [RabbitMQ](http://www.rabbitmq.com) middleware is used with some extra extensions. The data transport mechanism for pushing data from polling devices can be one of STOMP, AMQP, or raw UDP packets (recommended).\r\n\r\nInterruptus implements it's monitoring rules using the [Esper](http://esper.codehaus.org) complex event processing engine.\r\n\r\n## Fault tolerance\r\n\r\nThe plan here is to use [Apache Zookeeper](http://zookeeper.apache.org) and the [Curator](http://curator.incubator.apache.org) library to implement master/standby nodes, where each node contains the current CEP engine state and configuration.\r\n\r\nFailures in a master node are automatically detected and standby nodes can immediately continue processing data without dropping any data. This is accomplished by ensuring that all nodes in the cluster receive all data updates via AMQP topic routing.\r\n\r\n## Powerful visualization\r\n\r\nInterruptus integrates with [OpenTSDB](http://www.opentsdb.net) a powerful time series database and graphing engine. Because OpenTSDB stores data at native resolution, you can always go back and drill-down to event details right down to a single data point.\r\n\r\n## Ease of use\r\n\r\nSetting up monitoring rules should be easy. Once the aforementioned core functionality is built, the plan is to create a web UI that consumes the REST API to configure the CEP engine using a pre-built pattern library. Sample patterns might include:\r\n - Alert when value over X\r\n - Alert when N consecutive values over X\r\n - Alert when N consecutive rising values over X, with last value Y times greater than first\r\n - Find outlier in group of servers having metricX < or > avg(metricX) in cluster (hot/cold spots)\r\n - Alert when value > X * stddev\r\n - Alert when current values - previous value > X\r\n\r\nIt should be possible to combine patterns (tell me when the average load on my web server cluster is over X AND my database queries per second > Y). \r\n\r\nThe state of the configuration is fully exposed via a REST API, any UI's which consume it will be 'dumb' in the sense that they are simply accessing pre-built functions (eg: think static HTML page with jQuery wizardry).\r\n\r\n## Power user features\r\n\r\nOutside of pre-canned patterns, Interruptus can expose a method of adding custom EQL to fully utilize the power of the processing engine to express complex scenarios.\r\n\r\nPredictive modelling and forecasting is another planned feature (eg: Holt-Winters modelling), to know when things are going to break!\r\n\r\nTo accomplish this we may integrate [Esper-ext](http://github.com/antonioalegria/esper-ext), or [Openforecast](http://www.stevengould.org/software/openforecast/index.shtml).\r\n\r\nCommunication protocol specifications\r\n=====================================\r\n\r\nThe CEP engine expects input as JSON objects. For efficiency, a single AMQP message can contain multiple JSON objects seperated by a newline '\\n' character. Optionally, the payload can be compressed using the zlib compression algorithm.\r\n\r\nHere's an example payload:\r\n\r\n``` {\"plugin\":\"rabbitmq\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":2022,\"name\":\"messages\",\"host\":\"darkstar\",\"type_instance\":\"metrics\",\"plugin_instance\":\"_\",\"type\":\"rabbitmq\"}\r\n{\"plugin\":\"rabbitmq\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":0,\"name\":\"messages_rate\",\"host\":\"darkstar\",\"type_instance\":\"metrics\",\"plugin_instance\":\"_\",\"type\":\"rabbitmq\"}\r\n{\"plugin\":\"rabbitmq\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":0,\"name\":\"messages_unacknolwedged\",\"host\":\"darkstar\",\"type_instance\":\"metrics\",\"plugin_instance\":\"_\",\"type\":\"rabbitmq\"}\r\n{\"plugin\":\"rabbitmq\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":0,\"name\":\"messages_unacknowledged_rate\",\"host\":\"darkstar\",\"type_instance\":\"metrics\",\"plugin_instance\":\"_\",\"type\":\"rabbitmq\"}\r\n{\"plugin\":\"rabbitmq\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":2022,\"name\":\"messages_ready\",\"host\":\"darkstar\",\"type_instance\":\"metrics\",\"plugin_instance\":\"_\",\"type\":\"rabbitmq\"}\r\n{\"plugin\":\"interface\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":219589727,\"name\":\"rx\",\"host\":\"darkstar\",\"type_instance\":\"eth0\",\"type\":\"if_octets\"}\r\n{\"plugin\":\"interface\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":18433612,\"name\":\"tx\",\"host\":\"darkstar\",\"type_instance\":\"eth0\",\"type\":\"if_octets\"}\r\n{\"plugin\":\"interface\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":281652,\"name\":\"rx\",\"host\":\"darkstar\",\"type_instance\":\"eth0\",\"type\":\"if_packets\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":539471872,\"name\":\"read\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_octets\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":1653339136,\"name\":\"write\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_octets\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":20687,\"name\":\"read\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_ops\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":78754,\"name\":\"write\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_ops\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":13,\"name\":\"read\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_time\"}\r\n{\"plugin\":\"disk\",\"datacenter\":\"datacenter\",\"event_type\":\"CollectdMetric\",\"time\":1381216257,\"value\":231,\"name\":\"write\",\"host\":\"darkstar\",\"plugin_instance\":\"sda\",\"type\":\"disk_time\"}\r\n```\r\nEach input line in the AMQP payload is parsed as a JSON object, and an EventBean is automatically created to represent the object in the CEP stream processing engine. The event type is specified in the \"event_type\" property of the JSON object, and MUST be defined before you start submitting events to the engine. This can be accomplished via the REST API.\r\n\r\nConfiguration example\r\n=====================\r\n\r\nThe following example configures an event type in Interruptus and uses an AMQP inbound data flow to read AMQP messages.\r\n\r\n```\r\ncurl -X POST -H \"Accept:application/json\" -H \"Content-Type:application/json\" \\\r\n-d @- http://localhost:8080/interruptus/api/type \\\r\n<<EOF | python -m json.tool\r\n{\r\n  \"name\":\"CollectdMetric\",\r\n  \"properties\":[\r\n    {\"name\":\"plugin\",\"type\":\"string\"},\r\n    {\"name\":\"plugin_instance\",\"type\":\"string\"},\r\n    {\"name\":\"type\",\"type\":\"string\"},\r\n    {\"name\":\"type_instance\",\"type\":\"string\"},\r\n    {\"name\":\"datacenter\",\"type\":\"string\"},\r\n    {\"name\":\"time\",\"type\":\"long\"},\r\n    {\"name\":\"value\",\"type\":\"double\"},\r\n    {\"name\":\"name\",\"type\":\"string\"},\r\n    {\"name\":\"host\",\"type\":\"string\"},\r\n    {\"name\":\"event_type\",\"type\":\"string\"}\r\n  ]\r\n}\r\nEOF\r\ncurl -X POST -H \"Accept:application/json\" -H \"Content-Type:application/json\" \\\r\n-d @- http://localhost:8080/interruptus/api/statement \\\r\n<<EOF | python -m json.tool\r\n{\"name\": \"eventlogdebug\", \"query\":\"SELECT * FROM CollectdMetric\", \"debug\": true}\r\nEOF\r\n\r\ncurl -X POST -H \"Accept:application/json\" -H \"Content-Type:application/json\" \\\r\n-d @- http://localhost:8080/interruptus/api/flow \\\r\n<<EOF | python -m json.tool\r\n{\r\n  \"name\": \"EventsIn\", \r\n  \"query\":\"\r\n    create dataflow EventsIn AMQPSource -> EventsIn<CollectdMetric> { \r\n      host: 'localhost',  \r\n      exchange: 'collectd-metrics', \r\n      port: 5672, \r\n      username: 'guest', \r\n      password: 'guest',\r\n      routingKey: '#', \r\n      collector: {class: 'org.control_alt_del.interruptus.AMQPJsonToMap'}, \r\n      logMessages: true  \r\n  } EventBusSink(EventsIn){}\r\n\"\r\n}\r\nEOF\r\n```\r\n\r\nI have written some [Collectd](http://www.collectd.org) plugins to send data to RabbitMQ. [Plugins here](https://github.com/marksteele/collectd-plugins). My plugin is using a UDP transport to push messages into RabbitMQ using the [RabbitMQ UDP exchange plugin](https://github.com/tonyg/udp-exchange) (Poke tonyg to update his binary plugin build to latest RabbitMQ version, and maybe add some links for previous versions).\r\n\r\nStatus\r\n==================\r\n\r\nInitial CEP engine and REST API is complete and working. Next steps are clustering and development of the pattern library.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}