<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Interruptus : Infrastructure for scalable monitoring" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Interruptus</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/marksteele/interruptus">View on GitHub</a>

          <h1 id="project_title">Interruptus</h1>
          <h2 id="project_tagline">Infrastructure for scalable monitoring</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/marksteele/interruptus/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/marksteele/interruptus/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="interruptus" class="anchor" href="#interruptus"><span class="octicon octicon-link"></span></a>Interruptus</h1>

<p>A framework for scalable monitoring.</p>

<pre>
            _.---._
        .-'         '-.
     .'                 '.
    '       '.   .'       '
   / /        \ /        \ \
  '  |         :         |  '
 /   |         .         |   \
 |   \         |         /   |
 '. . \        |        / . .'
  |   .\      .'.      /.   |
  \  .  `-           -'  .  /
   '.      .. ... ..      .'
    |  `` ` .     . ` ``  |
    | .-_-.  '. .'  .-_-. |
   .'( (O) )|  :  |( (O) )'.
    \.'---'/   :   \'---'./
      \_ .'  . ' .  '. _/
     .' /             \ '.
     './ / /  / \ \  \ \.'
      : | | /|  : |  | :
      | : | \\  | '  : |
      | /\ \/ \ | : /\ :
      ' :/\ \ : ' ||  \ \
      / | /\ \| : ' \  \ \
     / / /  \/ /| :  |  \ \
    / / :   / /\ \ \ /   \ \
   ' /\ \  | /\ :.\ \    / |
   \ \ \ \ \/ / || \ \   \/
    \/  \|    \/ \/ |/
    
</pre>

<h1>
<a name="authors" class="anchor" href="#authors"><span class="octicon octicon-link"></span></a>Authors</h1>

<p>Mark Steele <a href="mailto:mark@control-alt-del.org">mark@control-alt-del.org</a></p>

<p>Fabio "Fantastico" B. Silva <a href="mailto:fabio.bat.silva@gmail.com">fabio.bat.silva@gmail.com</a></p>

<h1>
<a name="goals" class="anchor" href="#goals"><span class="octicon octicon-link"></span></a>Goals</h1>

<h2>
<a name="scalability" class="anchor" href="#scalability"><span class="octicon octicon-link"></span></a>Scalability</h2>

<p>A monitoring system should scale to fit the size of the systems you wish to monitor. Interruptus is designed to target the high end of the spectrum here as it requires multiple nodes and roles in an optimal deployment. </p>

<p>Guestimated initial performance targets for this system should be able to process at least tens of thousands of data points per second. Benchmarks to follow.</p>

<h2>
<a name="efficiency" class="anchor" href="#efficiency"><span class="octicon octicon-link"></span></a>Efficiency</h2>

<p>In order to achieve effective monitoring in large environments, a single data polling instance (eg: nagios) becomes a bottleneck and dangerous single point of failure.</p>

<p>The monitoring approach I would therefore propose is to use efficient node based polling software (for example collectd deployed to each node) to push data to Interruptus. There is of course nothing stopping you from using Nagios to poll all your nodes and push data to Interruptus.</p>

<p>I'm also a fan of not reinventing the wheel. That's why Interruptus leverages a best of breed software stack to focus on the core of the solution (monitoring!).</p>

<p>For data transport, the excellent <a href="http://www.rabbitmq.com">RabbitMQ</a> middleware is used with some extra extensions. The data transport mechanism for pushing data from polling devices can be one of STOMP, AMQP, or raw UDP packets (recommended).</p>

<p>Interruptus implements it's monitoring rules using the <a href="http://esper.codehaus.org">Esper</a> complex event processing engine.</p>

<h2>
<a name="fault-tolerance" class="anchor" href="#fault-tolerance"><span class="octicon octicon-link"></span></a>Fault tolerance</h2>

<p>The plan here is to use <a href="http://zookeeper.apache.org">Apache Zookeeper</a> and the <a href="http://curator.incubator.apache.org">Curator</a> library to implement master/standby nodes, where each node contains the current CEP engine state and configuration.</p>

<p>Failures in a master node are automatically detected and standby nodes can immediately continue processing data without dropping any data. This is accomplished by ensuring that all nodes in the cluster receive all data updates via AMQP topic routing.</p>

<h2>
<a name="powerful-visualization" class="anchor" href="#powerful-visualization"><span class="octicon octicon-link"></span></a>Powerful visualization</h2>

<p>Interruptus integrates with <a href="http://www.opentsdb.net">OpenTSDB</a> a powerful time series database and graphing engine. Because OpenTSDB stores data at native resolution, you can always go back and drill-down to event details right down to a single data point.</p>

<h2>
<a name="ease-of-use" class="anchor" href="#ease-of-use"><span class="octicon octicon-link"></span></a>Ease of use</h2>

<p>Setting up monitoring rules should be easy. Once the aforementioned core functionality is built, the plan is to create a web UI that consumes the REST API to configure the CEP engine using a pre-built pattern library. Sample patterns might include:</p>

<ul>
<li>Alert when value over X</li>
<li>Alert when N consecutive values over X</li>
<li>Alert when N consecutive rising values over X, with last value Y times greater than first</li>
<li>Find outlier in group of servers having metricX &lt; or &gt; avg(metricX) in cluster (hot/cold spots)</li>
<li>Alert when value &gt; X * stddev</li>
<li>Alert when current values - previous value &gt; X</li>
</ul><p>It should be possible to combine patterns (tell me when the average load on my web server cluster is over X AND my database queries per second &gt; Y). </p>

<p>The state of the configuration is fully exposed via a REST API, any UI's which consume it will be 'dumb' in the sense that they are simply access pre-built functions (eg: think static HTML page with jQuery wizardry).</p>

<h2>
<a name="power-user-features" class="anchor" href="#power-user-features"><span class="octicon octicon-link"></span></a>Power user features</h2>

<p>Outside of pre-canned patterns, Interruptus can expose a method of adding custom EQL to fully utilize the power of the processing engine to express complex scenarios.</p>

<p>Predictive modelling and forecasting is another planned feature (eg: Holt-Winters modelling), to know when things are going to break!</p>

<p>To accomplish this possible <a href="http://github.com/antonioalegria/esper-ext">Esper-ext</a>, or <a href="http://www.stevengould.org/software/openforecast/index.shtml">Openforecast</a>.</p>

<h1>
<a name="communication-protocol-specifications" class="anchor" href="#communication-protocol-specifications"><span class="octicon octicon-link"></span></a>Communication protocol specifications</h1>

<p>The CEP engine expects input as JSON objects. For efficiency, a single AMQP message can contain multiple JSON objects seperated by a newline '\n' character. Optionally, the payload can be compressed using the zlib compression algorithm.</p>

<p>Here's an example payload:</p>

<pre lang='"plugin":"rabbitmq","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":2022,"name":"messages","host":"darkstar","type_instance":"metrics","plugin_instance":"_","type":"rabbitmq"'><code>{"plugin":"rabbitmq","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":0,"name":"messages_rate","host":"darkstar","type_instance":"metrics","plugin_instance":"_","type":"rabbitmq"}
{"plugin":"rabbitmq","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":0,"name":"messages_unacknolwedged","host":"darkstar","type_instance":"metrics","plugin_instance":"_","type":"rabbitmq"}
{"plugin":"rabbitmq","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":0,"name":"messages_unacknowledged_rate","host":"darkstar","type_instance":"metrics","plugin_instance":"_","type":"rabbitmq"}
{"plugin":"rabbitmq","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":2022,"name":"messages_ready","host":"darkstar","type_instance":"metrics","plugin_instance":"_","type":"rabbitmq"}
{"plugin":"interface","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":219589727,"name":"rx","host":"darkstar","type_instance":"eth0","type":"if_octets"}
{"plugin":"interface","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":18433612,"name":"tx","host":"darkstar","type_instance":"eth0","type":"if_octets"}
{"plugin":"interface","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":281652,"name":"rx","host":"darkstar","type_instance":"eth0","type":"if_packets"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":539471872,"name":"read","host":"darkstar","plugin_instance":"sda","type":"disk_octets"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":1653339136,"name":"write","host":"darkstar","plugin_instance":"sda","type":"disk_octets"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":20687,"name":"read","host":"darkstar","plugin_instance":"sda","type":"disk_ops"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":78754,"name":"write","host":"darkstar","plugin_instance":"sda","type":"disk_ops"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":13,"name":"read","host":"darkstar","plugin_instance":"sda","type":"disk_time"}
{"plugin":"disk","datacenter":"datacenter","event_type":"CollectdMetric","time":1381216257,"value":231,"name":"write","host":"darkstar","plugin_instance":"sda","type":"disk_time"}
</code></pre>

<p>Each input line in the AMQP payload is parsed as a JSON object, and an EventBean is automatically created to represent the object in the CEP stream processing engine. The event type is specified in the "event_type" property of the JSON object, and MUST be defined before you start submitting events to the engine. This can be accomplished via the REST API.</p>

<h1>
<a name="configuration-example" class="anchor" href="#configuration-example"><span class="octicon octicon-link"></span></a>Configuration example</h1>

<p>The following example configures an event type in Interruptus and uses an AMQP inbound data flow to read AMQP messages.</p>

<pre><code>curl -X POST -H "Accept:application/json" -H "Content-Type:application/json" \
-d @- http://localhost:8080/interruptus/api/type \
&lt;&lt;EOF | python -m json.tool
{
  "name":"CollectdMetric",
  "properties":[
    {"name":"plugin","type":"string"},
    {"name":"plugin_instance","type":"string"},
    {"name":"type","type":"string"},
    {"name":"type_instance","type":"string"},
    {"name":"datacenter","type":"string"},
    {"name":"time","type":"long"},
    {"name":"value","type":"double"},
    {"name":"name","type":"string"},
    {"name":"host","type":"string"}
  ]
}
EOF
curl -X POST -H "Accept:application/json" -H "Content-Type:application/json" \
-d @- http://localhost:8080/interruptus/api/statement \
&lt;&lt;EOF | python -m json.tool
{"name": "eventlogdebug", "query":"SELECT * FROM CollectdMetric", "debug": true}
EOF

curl -X POST -H "Accept:application/json" -H "Content-Type:application/json" \
-d @- http://localhost:8080/interruptus/api/flow \
&lt;&lt;EOF | python -m json.tool
{"name": "EventsIn", "query":"create dataflow EventsIn AMQPSource -&gt; EventsIn&lt;CollectdMetric&gt; {  host: 'localhost',  exchange: 'collectd-metrics', port: 5672, username: 'guest',  password: 'guest',  routingKey: '#', collector: {class: 'org.control_alt_del.interruptus.AMQPJsonToMap'}, logMessages: true  } EventBusSink(EventsIn){}"}
EOF
</code></pre>

<p>I have written some <a href="http://www.collectd.org">Collectd</a> plugins to send data to RabbitMQ. <a href="https://github.com/marksteele/collectd-plugins">Plugins here</a>. My plugin is using a UDP transport to push messages into RabbitMQ using the <a href="https://github.com/tonyg/udp-exchange">RabbitMQ UDP exchange plugin</a> (Poke tonyg to update his binary plugin build to latest RabbitMQ version, and maybe add some links for previous versions).</p>

<h1>
<a name="status" class="anchor" href="#status"><span class="octicon octicon-link"></span></a>Status</h1>

<p>Initial CEP engine and REST API is complete and working. Next steps are clustering and development of the pattern library.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Interruptus maintained by <a href="https://github.com/marksteele">marksteele</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
